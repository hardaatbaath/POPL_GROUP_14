## Conclusions drawn for the results

1. **Execution Time:**

    * Python took the longest time to run compared to C++ and Rust. This suggests that Python may have higher execution times due to its interpreted nature and dynamic typing. C++ and Rust, being compiled languages, often exhibit faster execution times.
2. **CPU Utilization:**

    * Python showed the highest CPU utilization, indicating that it consumed more processing resources during execution. This could be attributed to the overhead of interpretation and dynamic typing in Python.
    * C++ and Rust had lower CPU utilization, with the two languages being close to each other. This might imply that these compiled languages are more efficient in terms of CPU resource management.
    3. **Analysis of result.jpeg Images:**

    * The images labeled as result.jpeg appear to provide a breakdown of the time taken by individual sections of the code.
    * Each section in the code may represent a distinct operation or function. Analyzing the images can offer insights into which specific parts of the code contribute the most to the overall execution time.
    * This kind of analysis can help in identifying bottlenecks or areas for optimization. For example, if a particular section in Python takes significantly longer than the corresponding sections in C++ and Rust, it might be a candidate for improvement or optimization.

In summary, the project suggests that Python, while convenient for its readability and ease of use, may have performance trade-offs compared to compiled languages like C++ and Rust. The detailed breakdown in the result.jpeg images allows for a more granular understanding of where the time is spent in the code execution, facilitating potential optimizations for future iterations of the project.